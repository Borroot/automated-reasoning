\documentclass{scrartcl}

\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{minted}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{multirow}
\usepackage[table]{xcolor}
\usepackage{svg}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{scalerel}
\usepackage{amsfonts}

\author{Jelmer Firet (s1023433, \href{mailto:jelmer.firet@ru.nl}{jelmer.firet@ru.nl}) \and
Bram Pulles (s1015194, \href{mailto:bram.pulles@ru.nl}{bram.pulles@ru.nl})}
\title{\textbf{Automated Reasoning\\Practical Assignment -- Part 2}}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{Automated Reasoning PA 2|Jelmer Firet \& Bram Pulles}
\fancyhead[R]{\thepage}

\setminted{autogobble,tabsize=4,fontsize=\scriptsize}
\setlength{\parindent}{0pt}


\begin{document}
\maketitle

\section{Groups} % (fold)
\label{sec:groups}
\begin{enumerate}[label=\alph*)]
\item
	We proved that $I*x=x$, $inv(inv(x))=x$ and $inv(x)*x=I$ by putting all of
	the given formulas \textit{literally} in prover9, see
	\texttt{groups\_a1.in}.

	Using mace4, we show that, in general, $inv(x*y)=inv(x)*inv(y)$ does not
	hold. The smallest group for which this does not hold has size $6$, see
	\texttt{groups\_a2.in} and appendix \ref{apx: groups}.
\item
	Using mace4, we show that the smallest non-Abelian group has size $6$,
	again by \textit{literally} putting in the formulas provided, see
	\texttt{groups\_b.in} and appendix \ref{apx: groups}.
\item
	We use the fact that $x^2 = x * x$, $x^3 = x * (x * x)$ and $x^4 = x * (x *
	(x * x))$ this makes encoding $x^n = I$ straightforward for $n = 2, 3, 4$.

	Using prover9, we show that for $n=2$ all such groups are Abelian, see \texttt{groups\_c1.in}.

	Using mace4, we show that for $n=3$ the group is not Abelian in general and
	the smallest counterexample has size $27$, see \texttt{groups\_c2.in}.

	Using mace4, we show that for $n=4$ the group is not Abelian and the
	smallest counterexample has size $8$, see \texttt{groups\_c3.in} and
	appendix \ref{apx: groups}.
\end{enumerate}
% section groups (end)

\section{Robot} % (fold)
\label{sec:robot}

	\subsection{Explanation} % (fold)
	\label{sub:explanation}
	In this problem we are given a grid with colored cells. We should program a robot for this grid so that the robot will always find it's way to one of the goal cells if it starts on any start cell.
	The robot can detect the color of the cell it is on and decide based on that color which direction to move. Our program should find the best assignment of directions to colors. We will Z3 to find this assignment.

	In our program we read the grid from a csv file.
	We then determine the number of colors in this grid.
	For each color we make a Z3 integer that will store the direction to move for that color. The values of this integer correspond to the following directions:\\

	\begin{tabular}{l|ll}
		value & direction & effect on coordinates\\
		\hline
		0 & north & decreasing row\\
		1 & east & increasing column\\
		2 & south & increasing row\\
		3 & west & decreasing column\\
	\end{tabular}\\

	To ensure that Z3 only assigns one of these, we add the following constraint:
	$$\mathtt{\forall_{color}: 0 \le direction[color] < 4}$$

	Now we want to evaluate the performance of an assignment. For this we want to know for every cell if we reach a destination, and if so in how many steps. We will add a Z3 integer storing this distance for every cell. For now we will say that this integer has the value $\infty$ if it can not reach a destination cell.\\

	We then specify how the distances interact with the commands. We will start with the simple cases; the destination and the lava. For a destination cell we do not need to move to reach a destination cell, therefore we add the following constraint:
	$$\mathtt{\forall_{0\le r<R}\forall_{0\le c<C}\text{ if }grid[r][c]=DESTINATION: dist[r][c]=0}$$
	We do something similar for lava. From a lava cell we cannot reach a destination cell, so we add the following constraint:
	$$\mathtt{\forall_{0\le r<R}\forall_{0\le c<C}\text{ if }grid[r][c]=LAVA: dist[r][c]=\infty}$$

	Now we will specify what the robot does for regular cells. For convenience we have a function $\mathtt{next(r,c,direction,steps)}$ that give the position we go to when we take $\mathtt{steps}$ steps to $\mathtt{direction}$ from cell $(\mathtt{r},\mathtt{c})$. This function takes into account that the robot stops at the edges of the grid.
	\begin{align*}
		&\mathtt{\forall_{0\le r<R}\forall_{0\le c<C}\forall_{0\le dir<4}\text{ if }\neg special(grid[r][c]):}\\
		&\mathtt{direction[grid[r][c]]=dir \implies dist[r][c]=1+dist[nr][nc]}\\
		&\text{ where }
		\mathtt{(nr,nc) = next(r,c,dir,1)}
	\end{align*}
	Note that we consider $1+\infty=\infty$. When we give $\infty$ an actual value, we will have to specify this special case explicitly.

	We can now specify how the ice cells work. We want $\mathtt{dist[r][c]}$ to store the worst-case distance to a destination cell. We will have a similar condition to the one for the regular cells, but take the maximum of the cells where we can end up. This translates into the following constraint:
	\begin{align*}
		&\mathtt{\forall_{0\le r<R}\forall_{0\le c<C}\forall_{0\le dir<4}\text{ if } grid[r][c] = ICE:}\\
		&\mathtt{direction[grid[r][c]]=dir \implies dist[r][c]=1+\max(dist[nr][nc],dist[nr',nc'])}\\
		&\text{ where }
		\mathtt{(nr,nc) = next(r,c,dir,1) \text{ and } (nr',nc') = next(r,c,dir,2)}
	\end{align*}

	Now we are ready to specify what we want to achieve, we want an assignment of directions to colors that minimizes
	$$\mathtt{\max_{0\le r < R, 0\le c < C, grid[r][c]=START} dist[r][c]}$$
	We do this by adding a Z3 integer for this goal and ask the Z3 optimizer to minimize this variable. Then we add the following constraint:
	$$\mathtt{\forall_{0\le r<R}\forall_{0\le c<C}\text{ if }grid[r][c]=START: dist[r][c]\le goal}$$

	Now we can choose a value for $\infty$. We do not want the $\mathtt{dist[r][c]}$ of start cells to be infinite, but otherwise the value does not matter. Therefore we choose the value of $\infty$ to be $\mathtt{goal+1}$. Then in all of the previous constraints of the form $\mathtt{dist[r][c]=\ldots}$ we add the extra option that $\mathtt{dist[r][c]=goal+1}$. This allows Z3 to assign values to all distances even in the case of an infinite loop.
	% subsection explanation (end)

	\subsection{Results} % (fold)
	\label{sub:results}
	When we run our program on the demogrid, we find that the minimal solution uses 11 steps\footnote{The problem statement gives a "solution for 10 steps", but the image shows a solution with 11 steps}. The assignment of directions is visualized in figure \ref{robot-demogrid-solution}.

	On grid (a) our program finds that the minimal solution uses 14 steps. The assignment of directions is visualized in figure \ref{robot-grid-a-solution}

	On grid (b) our program also finds a minimal solution of 14 steps, which is visualised in figure \ref{robot-grid-b-solution}

	On grid (c) our program also finds a minimal solution of 18 steps, which is visualised in figure \ref{robot-grid-c-solution}

	\begin{figure}
		\begin{subfigure}{0.5\textwidth}
			\includegraphics[width=0.9\textwidth]{resources/Screenshot from 2022-11-21 12-14-49.png}
			\caption{Solution for demo grid}
			\label{robot-demogrid-solution}
		\end{subfigure}
		\begin{subfigure}{0.5\textwidth}
			\includegraphics[width=0.9\textwidth]{resources/Screenshot from 2022-11-21 12-20-11.png}
			\caption{Solution for grid (a)}
			\label{robot-grid-a-solution}
		\end{subfigure}
		\begin{subfigure}{0.5\textwidth}
			\includegraphics[width=0.9\textwidth]{resources/Screenshot from 2022-11-21 12-21-43.png}
			\caption{Solution for grid (b)}
			\label{robot-grid-b-solution}
		\end{subfigure}
		\begin{subfigure}{0.5\textwidth}
			\includegraphics[width=0.9\textwidth]{resources/Screenshot from 2022-11-21 12-23-17.png}
			\caption{Solution for grid (c)}
			\label{robot-grid-c-solution}
		\end{subfigure}

	\end{figure}
	% subsection results (end)

% section robot (end)
\appendix
\pagebreak
\section{Groups}
\label{apx: groups}
\begin{enumerate}[label=\alph*)]
	\item
		Smallest finite group for which $inv(x*y)=inv(x)*inv(y)$ does not hold.
		\begin{verbatim}
		interpretation( 6, [number=1, seconds=0], [

		    function(I, [ 0 ]),

		    function(c1, [ 1 ]),

		    function(c2, [ 2 ]),

		    function(inv(_), [ 0, 1, 2, 4, 3, 5 ]),

		    function(*(_,_), [
		        0, 1, 2, 3, 4, 5,
		        1, 0, 3, 2, 5, 4,
		        2, 4, 0, 5, 1, 3,
		        3, 5, 1, 4, 0, 2,
		        4, 2, 5, 0, 3, 1,
		        5, 3, 4, 1, 2, 0 ])
		]).
		\end{verbatim}

	\item
		Smallest non-abelian group.
		\begin{verbatim}
		interpretation( 6, [number=1, seconds=0], [

			    function(I, [ 0 ]),

			    function(c1, [ 1 ]),

			    function(c2, [ 2 ]),

			    function(inv(_), [ 0, 1, 2, 4, 3, 5 ]),

			    function(*(_,_), [
			        0, 1, 2, 3, 4, 5,
			        1, 0, 3, 2, 5, 4,
			        2, 4, 0, 5, 1, 3,
			        3, 5, 1, 4, 0, 2,
			        4, 2, 5, 0, 3, 1,
			        5, 3, 4, 1, 2, 0 ])
		]).
		\end{verbatim}

	\item
		\pagebreak
		Smallest non-abelian group with $x^4 = I$.
		\begin{verbatim}
		interpretation( 6, [number=1, seconds=0], [

			    function(I, [ 0 ]),

			    function(c1, [ 1 ]),

			    function(c2, [ 2 ]),

			    function(inv(_), [ 0, 1, 2, 4, 3, 5, 6, 7 ]),

			    function(*(_,_), [
			        0, 1, 2, 3, 4, 5, 6, 7,
			        1, 0, 3, 2, 5, 4, 7, 6,
			        2, 4, 0, 6, 1, 7, 3, 5,
			        3, 5, 1, 7, 0, 6, 2, 4,
			        4, 2, 6, 0, 7, 1, 5, 3,
			        5, 3, 7, 1, 6, 0, 4, 2,
			        6, 7, 4, 5, 2, 3, 0, 1,
			        7, 6, 5, 4, 3, 2, 1, 0 ])
		]).
		\end{verbatim}
\end{enumerate}

\end{document}
